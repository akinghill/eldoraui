{
  "name": "swirl",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion"
  ],
  "files": [
    {
      "path": "eldoraui/swirlbg.tsx",
      "content": "import React, { useEffect, useRef } from \"react\";\nimport { createNoise3D } from \"simplex-noise\";\nimport { motion } from \"framer-motion\";\nimport { cn } from \"@/lib/utils\";\n\ninterface ParticleProps {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  ttl: number;\n  speed: number;\n  size: number;\n  hue: number;\n}\n\ninterface SwirlProps {\n  children?: React.ReactNode;\n  className?: string;\n  containerClassName?: string;\n  particleCount?: number;\n  baseTTL?: number;\n  rangeTTL?: number;\n  baseSpeed?: number;\n  rangeSpeed?: number;\n  baseSize?: number;\n  rangeSize?: number;\n  baseHue?: number;\n  rangeHue?: number;\n  backgroundColor?: string;\n}\n\nconst Swirl: React.FC<SwirlProps> = (props) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const particleCount = props.particleCount || 700;\n  const particlePropCount = 9;\n  const particlePropsLength = particleCount * particlePropCount;\n  const baseTTL = props.baseTTL || 100;\n  const rangeTTL = props.rangeTTL || 500;\n  const baseSpeed = props.baseSpeed || 0.1;\n  const rangeSpeed = props.rangeSpeed || 1;\n  const baseSize = props.baseSize || 2;\n  const rangeSize = props.rangeSize || 10;\n  const baseHue = props.baseHue || 10;\n  const rangeHue = props.rangeHue || 100;\n  const noiseSteps = 2;\n  const xOff = 0.0025;\n  const yOff = 0.005;\n  const zOff = 0.0005;\n  const backgroundColor = props.backgroundColor || \"hsla(60,50%,3%,1)\";\n  let tick = 0;\n  const noise3D = createNoise3D();\n  let particleProps = new Float32Array(particlePropsLength);\n  let center: [number, number] = [0, 0];\n\n  const HALF_PI: number = 0.5 * Math.PI;\n  const TAU: number = 2 * Math.PI;\n  const rand = (n: number): number => n * Math.random();\n  const randRange = (n: number): number => n - rand(2 * n);\n  const fadeInOut = (t: number, m: number): number => {\n    let hm = 0.5 * m;\n    return Math.abs(((t + hm) % m) - hm) / hm;\n  };\n  const lerp = (n1: number, n2: number, speed: number): number =>\n    (1 - speed) * n1 + speed * n2;\n\n  const angle = (x1: number, y1: number, x2: number, y2: number): number =>\n    Math.atan2(y2 - y1, x2 - x1);\n\n  const setup = () => {\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    if (canvas && container) {\n      const ctx = canvas.getContext(\"2d\");\n      if (ctx) {\n        resize(canvas, ctx);\n        initParticles();\n        draw(canvas, ctx);\n      }\n    }\n  };\n\n  const initParticles = () => {\n    tick = 0;\n    particleProps = new Float32Array(particlePropsLength);\n\n    for (let i = 0; i < particlePropsLength; i += particlePropCount) {\n      initParticle(i);\n    }\n  };\n\n  const initParticle = (i: number) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    let x, y, theta, vx, vy, life, ttl, speed, size, hue;\n\n    x = rand(canvas.width);\n    y = rand(canvas.height);\n    theta = angle(x, y, center[0], center[1]);\n    vx = Math.cos(theta) * 6;\n    vy = Math.sin(theta) * 6;\n    life = 0;\n    ttl = baseTTL + rand(rangeTTL);\n    speed = baseSpeed + rand(rangeSpeed);\n    size = baseSize + rand(rangeSize);\n    hue = baseHue + rand(rangeHue);\n\n    particleProps.set([x, y, vx, vy, life, ttl, speed, size, hue], i);\n  };\n\n  const draw = (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => {\n    tick++;\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    drawParticles(ctx);\n    renderGlow(canvas, ctx);\n    render(canvas, ctx);\n\n    window.requestAnimationFrame(() => draw(canvas, ctx));\n  };\n\n  const drawParticles = (ctx: CanvasRenderingContext2D) => {\n    for (let i = 0; i < particlePropsLength; i += particlePropCount) {\n      updateParticle(i, ctx);\n    }\n  };\n\n  const updateParticle = (i: number, ctx: CanvasRenderingContext2D) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    let i2 = 1 + i,\n      i3 = 2 + i,\n      i4 = 3 + i,\n      i5 = 4 + i,\n      i6 = 5 + i,\n      i7 = 6 + i,\n      i8 = 7 + i,\n      i9 = 8 + i;\n    let x, y, theta, vx, vy, life, ttl, speed, x2, y2, size, hue;\n\n    x = particleProps[i];\n    y = particleProps[i2];\n    theta = angle(x, y, center[0], center[1]) + 0.75 * HALF_PI;\n    vx = lerp(particleProps[i3], 2 * Math.cos(theta), 0.05);\n    vy = lerp(particleProps[i4], 2 * Math.sin(theta), 0.05);\n    life = particleProps[i5];\n    ttl = particleProps[i6];\n    speed = particleProps[i7];\n    x2 = x + vx * speed;\n    y2 = y + vy * speed;\n    size = particleProps[i8];\n    hue = particleProps[i9];\n\n    drawParticle(x, y, theta, life, ttl, size, hue, ctx);\n\n    life++;\n\n    particleProps[i] = x2;\n    particleProps[i2] = y2;\n    particleProps[i3] = vx;\n    particleProps[i4] = vy;\n    particleProps[i5] = life;\n\n    life > ttl && initParticle(i);\n  };\n\n  const drawParticle = (\n    x: number,\n    y: number,\n    theta: number,\n    life: number,\n    ttl: number,\n    size: number,\n    hue: number,\n    ctx: CanvasRenderingContext2D,\n  ) => {\n    const xRel = x - 0.5 * size;\n    const yRel = y - 0.5 * size;\n\n    ctx.save();\n    ctx.lineCap = \"round\";\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = `hsla(${hue},100%,60%,${fadeInOut(life, ttl)})`;\n    ctx.beginPath();\n    ctx.translate(xRel, yRel);\n    ctx.rotate(theta);\n    ctx.translate(-xRel, -yRel);\n    ctx.strokeRect(xRel, yRel, size, size);\n    ctx.closePath();\n    ctx.restore();\n  };\n\n  const resize = (\n    canvas: HTMLCanvasElement,\n    ctx?: CanvasRenderingContext2D,\n  ) => {\n    const { innerWidth, innerHeight } = window;\n\n    canvas.width = innerWidth;\n    canvas.height = innerHeight;\n\n    center[0] = 0.5 * canvas.width;\n    center[1] = 0.5 * canvas.height;\n  };\n\n  const renderGlow = (\n    canvas: HTMLCanvasElement,\n    ctx: CanvasRenderingContext2D,\n  ) => {\n    ctx.save();\n    ctx.filter = \"blur(8px) brightness(200%)\";\n    ctx.globalCompositeOperation = \"lighter\";\n    ctx.drawImage(canvas, 0, 0);\n    ctx.restore();\n\n    ctx.save();\n    ctx.filter = \"blur(4px) brightness(200%)\";\n    ctx.globalCompositeOperation = \"lighter\";\n    ctx.drawImage(canvas, 0, 0);\n    ctx.restore();\n  };\n\n  const render = (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => {\n    ctx.save();\n    ctx.globalCompositeOperation = \"lighter\";\n    ctx.drawImage(canvas, 0, 0);\n    ctx.restore();\n  };\n\n  useEffect(() => {\n    setup();\n    window.addEventListener(\"resize\", () => {\n      const canvas = canvasRef.current;\n      const ctx = canvas?.getContext(\"2d\");\n      if (canvas && ctx) {\n        resize(canvas, ctx);\n      }\n    });\n  }, []);\n\n  return (\n    <div className={cn(\"relative h-full w-full\", props.containerClassName)}>\n      <motion.div\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        ref={containerRef}\n        className={cn(\"absolute inset-0\", props.className)}\n      >\n        <canvas ref={canvasRef} />\n        {props.children}\n      </motion.div>\n    </div>\n  );\n};\n\nexport default Swirl;\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}